# Tutorial: Understanding OnSearchTextChanged Partial Method Binding

## Table of Contents
1. [Introduction](#introduction)
2. [Prerequisites](#prerequisites)
3. [The Magic of Source Generators](#the-magic-of-source-generators)
4. [Step-by-Step Breakdown](#step-by-step-breakdown)
5. [Hands-On Example](#hands-on-example)
6. [Common Patterns](#common-patterns)
7. [Troubleshooting](#troubleshooting)
8. [Best Practices](#best-practices)

---

## Introduction

If you're new to **CommunityToolkit.Mvvm** and wondering how `OnSearchTextChanged` magically gets called when the `SearchText` property changes, you're in the right place! This tutorial will demystify the entire process.

### What You'll Learn
- âœ… How `[ObservableProperty]` attribute works
- âœ… What partial methods are and why they're useful
- âœ… How XAML binding connects to your ViewModel
- âœ… The complete data flow from UI to code
- âœ… When and why to use this pattern

---

## Prerequisites

Before diving in, make sure you have:

```xml
<!-- In your .csproj file -->
<PackageReference Include="CommunityToolkit.Mvvm" Version="8.4.0" />
```

And your ViewModel inherits from `ObservableObject` or uses `[ObservableObject]`:

```csharp
using CommunityToolkit.Mvvm.ComponentModel;

public partial class MyViewModel : ObservableObject
{
    // Your code here
}
```

---

## The Magic of Source Generators

### What is a Source Generator?

A **source generator** is a compiler feature that **generates code for you at compile time**. Think of it as a code assistant that writes boilerplate code automatically.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Your Code  â”‚ â”€â”€â–¶  â”‚ Source Generator â”‚ â”€â”€â–¶  â”‚ Generated Code  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                                                â”‚
        â”‚                                                â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚ Compiled App   â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Why Source Generators?

**Before Source Generators** (Manual MVVM):
```csharp
private string _searchText;
public string SearchText
{
    get => _searchText;
    set
    {
        if (_searchText != value)
        {
            _searchText = value;
            OnPropertyChanged(nameof(SearchText));
            // Call custom logic here
        }
    }
}

public event PropertyChangedEventHandler PropertyChanged;
protected void OnPropertyChanged(string propertyName)
{
    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
}
```
**Problems**: 
- âŒ Lots of repetitive code
- âŒ Easy to make mistakes
- âŒ Hard to maintain

**With Source Generators** (CommunityToolkit.Mvvm):
```csharp
[ObservableProperty]
private string _searchText = string.Empty;

partial void OnSearchTextChanged(string value)
{
    // Your custom logic here
}
```
**Benefits**: 
- âœ… Clean, concise code
- âœ… Compiler generates the boilerplate
- âœ… Easy to read and maintain

---

## Step-by-Step Breakdown

### Step 1: You Write This

```csharp
public partial class PlantListOverviewViewModel : ViewModelBase
{
    [ObservableProperty]
    private string _searchText = string.Empty;
    
    partial void OnSearchTextChanged(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            // Reset the plant list
            await ResetPlantsAsync();
        }
    }
}
```

**Key Points**:
- âœ… The class must be `partial`
- âœ… Field starts with underscore: `_searchText`
- âœ… Field is `private`
- âœ… Decorated with `[ObservableProperty]`
- âœ… Optional partial method: `OnSearchTextChanged`

### Step 2: Source Generator Creates This

During compilation, the MVVM Toolkit generates code in a separate file:

**Generated File**: `PlantListOverviewViewModel.g.cs`

```csharp
// <auto-generated/>
partial class PlantListOverviewViewModel
{
    /// <summary>
    /// Generated property for _searchText
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("...", "...")]
    public string SearchText
    {
        get => _searchText;
        set
        {
            if (!global::System.Collections.Generic.EqualityComparer<string>
                .Default.Equals(_searchText, value))
            {
                string oldValue = _searchText;
                
                // Call partial method BEFORE change (if implemented)
                OnSearchTextChanging(value);
                OnSearchTextChanging(oldValue, value);
                
                // Update the value
                _searchText = value;
                
                // Notify UI of property change
                OnPropertyChanged(nameof(SearchText));
                
                // Call partial method AFTER change (if implemented) â­
                OnSearchTextChanged(value);
                OnSearchTextChanged(oldValue, value);
            }
        }
    }
    
    // Partial method declarations (you can implement these)
    partial void OnSearchTextChanging(string value);
    partial void OnSearchTextChanging(string oldValue, string newValue);
    partial void OnSearchTextChanged(string value);
    partial void OnSearchTextChanged(string oldValue, string newValue);
}
```

**What This Means**:
1. A public property `SearchText` is created
2. It includes full `INotifyPropertyChanged` implementation
3. It automatically calls your `OnSearchTextChanged` method
4. All this happens at **compile time** - no runtime overhead!

### Step 3: XAML Binds to the Property

```xml
<SearchBar Text="{Binding SearchText}" />
```

**What the Binding Does**:
- **View â†’ ViewModel**: When user types, updates `SearchText` property
- **ViewModel â†’ View**: When `SearchText` changes in code, updates SearchBar

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   SearchBar   â”‚
â”‚   (XAML UI)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚ Two-Way Binding
        â”‚ Text="{Binding SearchText}"
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   SearchText          â”‚  â¬… Generated Property
â”‚   (Public Property)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚ Calls when value changes
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OnSearchTextChanged   â”‚  â¬… Your Custom Code
â”‚ (Partial Method)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Step 4: The Complete Flow

Let's trace what happens when a user types "Rose" in the SearchBar:

```
1. User types "R" in SearchBar
   â†“
2. XAML binding detects change
   Text property changed: "" â†’ "R"
   â†“
3. Binding updates ViewModel property
   SearchText = "R"
   â†“
4. Generated SearchText.set() is called
   â†“
5. Check if value actually changed
   if ("" != "R") // True!
   â†“
6. Call OnSearchTextChanging("R")
   (if you implemented it - optional)
   â†“
7. Update backing field
   _searchText = "R"
   â†“
8. Raise PropertyChanged event
   OnPropertyChanged("SearchText")
   â†“
9. Call OnSearchTextChanged("R") â­
   Your custom logic executes!
   â†“
10. User sees updated UI
```

---

## Hands-On Example

Let's build a complete working example from scratch!

### 1. Create the ViewModel

**File**: `SearchExampleViewModel.cs`

```csharp
using CommunityToolkit.Mvvm.ComponentModel;
using System.Collections.ObjectModel;
using System.Diagnostics;

namespace MyApp.ViewModels;

public partial class SearchExampleViewModel : ObservableObject
{
    // Observable property - MVVM Toolkit will generate the public property
    [ObservableProperty]
    private string _searchText = string.Empty;
    
    // Collection of items to search
    public ObservableCollection<string> Items { get; } = new()
    {
        "Apple", "Banana", "Cherry", "Date", "Elderberry"
    };
    
    public ObservableCollection<string> FilteredItems { get; } = new();
    
    // Constructor - initialize with all items
    public SearchExampleViewModel()
    {
        foreach (var item in Items)
        {
            FilteredItems.Add(item);
        }
    }
    
    // This method is called automatically when SearchText changes!
    partial void OnSearchTextChanged(string value)
    {
        Debug.WriteLine($"[Search] Text changed to: '{value}'");
        
        // If search text is empty, show all items
        if (string.IsNullOrWhiteSpace(value))
        {
            FilteredItems.Clear();
            foreach (var item in Items)
            {
                FilteredItems.Add(item);
            }
            Debug.WriteLine("[Search] Showing all items");
        }
        else
        {
            // Filter items based on search text
            FilteredItems.Clear();
            var filtered = Items.Where(x => 
                x.Contains(value, StringComparison.OrdinalIgnoreCase));
            
            foreach (var item in filtered)
            {
                FilteredItems.Add(item);
            }
            Debug.WriteLine($"[Search] Found {FilteredItems.Count} matching items");
        }
    }
    
    // Optional: Called BEFORE value changes (for validation)
    partial void OnSearchTextChanging(string value)
    {
        Debug.WriteLine($"[Search] About to change to: '{value}'");
        
        // You could validate here and throw exception to prevent change
        // if (value.Length > 100)
        //     throw new ArgumentException("Search text too long!");
    }
}
```

### 2. Create the XAML View

**File**: `SearchExamplePage.xaml`

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage 
    xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
    xmlns:vm="clr-namespace:MyApp.ViewModels"
    x:Class="MyApp.Views.SearchExamplePage"
    x:DataType="vm:SearchExampleViewModel"
    Title="Search Example">
    
    <StackLayout Padding="20" Spacing="10">
        
        <!-- SearchBar bound to SearchText property -->
        <SearchBar 
            Placeholder="Type to search..."
            Text="{Binding SearchText}" />
        
        <!-- Display current search text -->
        <Label>
            <Label.FormattedText>
                <FormattedString>
                    <Span Text="Searching for: " FontAttributes="Bold" />
                    <Span Text="{Binding SearchText}" />
                </FormattedString>
            </Label.FormattedText>
        </Label>
        
        <!-- Display filtered results -->
        <Label 
            Text="{Binding FilteredItems.Count, StringFormat='Found {0} items'}" 
            FontAttributes="Italic" />
        
        <CollectionView ItemsSource="{Binding FilteredItems}">
            <CollectionView.ItemTemplate>
                <DataTemplate>
                    <Label 
                        Text="{Binding .}" 
                        Padding="10,5" 
                        FontSize="16" />
                </DataTemplate>
            </CollectionView.ItemTemplate>
        </CollectionView>
        
    </StackLayout>
</ContentPage>
```

### 3. Code-Behind (Minimal)

**File**: `SearchExamplePage.xaml.cs`

```csharp
namespace MyApp.Views;

public partial class SearchExamplePage : ContentPage
{
    public SearchExamplePage(SearchExampleViewModel viewModel)
    {
        InitializeComponent();
        BindingContext = viewModel;
    }
}
```

### 4. Register in DI Container

**File**: `MauiProgram.cs`

```csharp
builder.Services.AddTransient<SearchExampleViewModel>();
builder.Services.AddTransient<SearchExamplePage>();
```

### 5. Test It!

Run the app and:
1. Type "a" â†’ See: Apple, Banana, Date
2. Type "ap" â†’ See: Apple
3. Clear the search â†’ See all items
4. Check Debug output to see the flow

**Debug Output**:
```
[Search] About to change to: 'a'
[Search] Text changed to: 'a'
[Search] Found 3 matching items
[Search] About to change to: 'ap'
[Search] Text changed to: 'ap'
[Search] Found 1 matching items
[Search] About to change to: ''
[Search] Text changed to: ''
[Search] Showing all items
```

---

## Common Patterns

### Pattern 1: Debounced Search

Avoid searching on every keystroke - wait until user stops typing:

```csharp
private CancellationTokenSource? _searchCts;

partial void OnSearchTextChanged(string value)
{
    // Cancel previous search
    _searchCts?.Cancel();
    _searchCts = new CancellationTokenSource();
    
    // Wait 300ms before searching
    Task.Run(async () =>
    {
        try
        {
            await Task.Delay(300, _searchCts.Token);
            await PerformSearchAsync(value);
        }
        catch (TaskCanceledException)
        {
            // Search was cancelled by new keystroke
        }
    });
}
```

### Pattern 2: Validation

Prevent invalid values:

```csharp
partial void OnSearchTextChanging(string value)
{
    if (value.Length > 50)
    {
        throw new ArgumentException("Search text is too long!");
    }
}
```

### Pattern 3: Track Old and New Values

```csharp
partial void OnSearchTextChanged(string oldValue, string newValue)
{
    Debug.WriteLine($"Changed from '{oldValue}' to '{newValue}'");
    
    if (oldValue.Length > newValue.Length)
    {
        Debug.WriteLine("User is deleting text");
    }
}
```

### Pattern 4: Async Operations

```csharp
partial void OnSearchTextChanged(string value)
{
    // Fire and forget (be careful!)
    _ = Task.Run(async () =>
    {
        try
        {
            IsLoading = true;
            var results = await SearchApiAsync(value);
            await MainThread.InvokeOnMainThreadAsync(() =>
            {
                UpdateResults(results);
            });
        }
        finally
        {
            IsLoading = false;
        }
    });
}
```

---

## Troubleshooting

### Issue 1: "Partial method not being called"

**Symptoms**: Your `OnSearchTextChanged` method doesn't execute.

**Checklist**:
- âœ… Is your class marked as `partial`?
  ```csharp
  public partial class MyViewModel  // âœ… Has 'partial'
  ```
  
- âœ… Is the field marked with `[ObservableProperty]`?
  ```csharp
  [ObservableProperty]  // âœ… Has attribute
  private string _searchText;
  ```

- âœ… Is the method signature correct?
  ```csharp
  // âœ… Correct
  partial void OnSearchTextChanged(string value)
  
  // âŒ Wrong - missing 'partial'
  void OnSearchTextChanged(string value)
  
  // âŒ Wrong - wrong name
  partial void OnSearchChanged(string value)
  ```

- âœ… Did you rebuild the project?
  - Clean â†’ Rebuild Solution
  - Source generators run at compile time!

### Issue 2: "Property not updating UI"

**Symptoms**: UI doesn't update when property changes.

**Solutions**:
1. Check XAML binding:
   ```xml
   <!-- âœ… Correct -->
   <SearchBar Text="{Binding SearchText}" />
   
   <!-- âŒ Wrong - typo -->
   <SearchBar Text="{Binding SearchTxt}" />
   ```

2. Ensure BindingContext is set:
   ```csharp
   public MyPage(MyViewModel viewModel)
   {
       InitializeComponent();
       BindingContext = viewModel;  // âœ… Don't forget this!
   }
   ```

3. Check ViewModel inheritance:
   ```csharp
   // âœ… Correct
   public partial class MyViewModel : ObservableObject
   
   // âŒ Wrong - missing ObservableObject
   public partial class MyViewModel
   ```

### Issue 3: "Generated code not found"

**Solution**: Check generated files:
1. Enable "Show All Files" in Solution Explorer
2. Navigate to: `obj/Debug/net10.0-android/generated/`
3. Look for: `YourViewModel.g.cs`

If missing:
- Clean and rebuild
- Check for compilation errors
- Ensure CommunityToolkit.Mvvm package is installed

### Issue 4: "Method called multiple times"

**Cause**: Multiple bindings or duplicate subscriptions.

**Solution**:
- Check for duplicate XAML bindings
- Ensure you're not manually calling `OnPropertyChanged`
- Use debouncing (see Pattern 1)

---

## Best Practices

### DO âœ…

1. **Keep partial methods simple and fast**
   ```csharp
   // âœ… Good - quick operation
   partial void OnSearchTextChanged(string value)
   {
       if (string.IsNullOrWhiteSpace(value))
           ResetFilter();
   }
   ```

2. **Use async carefully**
   ```csharp
   // âœ… Good - fire and forget with error handling
   partial void OnSearchTextChanged(string value)
   {
       _ = Task.Run(async () =>
       {
           try { await SearchAsync(value); }
           catch (Exception ex) { LogError(ex); }
       });
   }
   ```

3. **Use meaningful names**
   ```csharp
   // âœ… Good
   [ObservableProperty]
   private string _searchText;
   
   // âŒ Bad
   [ObservableProperty]
   private string _txt;
   ```

4. **Document complex logic**
   ```csharp
   /// <summary>
   /// Automatically filters plants when search text changes.
   /// Resets to show all plants when search is cleared.
   /// </summary>
   partial void OnSearchTextChanged(string value)
   {
       // ...
   }
   ```

### DON'T âŒ

1. **Don't do heavy operations**
   ```csharp
   // âŒ Bad - blocks UI thread
   partial void OnSearchTextChanged(string value)
   {
       Thread.Sleep(5000);  // DON'T!
       var results = ExpensiveSearch(value);
   }
   ```

2. **Don't modify the property itself**
   ```csharp
   // âŒ Bad - infinite loop!
   partial void OnSearchTextChanged(string value)
   {
       SearchText = value.ToUpper();  // Triggers change again!
   }
   ```

3. **Don't ignore exceptions**
   ```csharp
   // âŒ Bad - silently fails
   partial void OnSearchTextChanged(string value)
   {
       try
       {
           RiskyOperation(value);
       }
       catch { /* ignored */ }
   }
   ```

---

## Summary

### Key Takeaways

1. **`[ObservableProperty]`** generates a public property with full INotifyPropertyChanged support
2. **`partial void OnXxxChanged`** is called automatically when the property changes
3. **No explicit binding** to the partial method is needed - it's wired up by the source generator
4. **XAML binds to the generated property**, not the partial method
5. **The magic happens at compile time** via source generators

### The Complete Picture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Your Code (Written)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  [ObservableProperty]                                       â”‚
â”‚  private string _searchText;                                â”‚
â”‚                                                             â”‚
â”‚  partial void OnSearchTextChanged(string value) { ... }    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â”‚ Compile Time
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Generated Code (Auto-Created)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  public string SearchText                                   â”‚
â”‚  {                                                          â”‚
â”‚      get => _searchText;                                   â”‚
â”‚      set                                                    â”‚
â”‚      {                                                      â”‚
â”‚          _searchText = value;                              â”‚
â”‚          OnPropertyChanged("SearchText");                  â”‚
â”‚          OnSearchTextChanged(value); â­                    â”‚
â”‚      }                                                      â”‚
â”‚  }                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â”‚ Runtime
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    XAML Binding                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  <SearchBar Text="{Binding SearchText}" />                  â”‚
â”‚                                                             â”‚
â”‚  User types â†’ Binding updates â†’ Property changes â†’         â”‚
â”‚  OnSearchTextChanged executes â†’ Your logic runs!           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Next Steps

- Try the hands-on example
- Experiment with different partial method signatures
- Explore other MVVM Toolkit features (RelayCommand, ObservableValidator, etc.)
- Read the [official documentation](https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/)

---

**Happy Coding! ğŸš€**

*For more information, see the [MVVM Toolkit Documentation](https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/)*
